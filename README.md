# DataStructures-And-AlgoProjects
My code for CS187 - Programming with Data Structures (Spring 2023) weekly programming projects. I got 100 on all of them.
Below are the projects' summaries.

**1)Project Overview: Project1**
Overview:
Create an ArrayList manipulation utility in Java that performs operations on generic lists. The utility enables removing duplicates, finding set differences, and determining set intersections. 
It showcases skills like Java programming, generics, collections, logical problem-solving, and method implementation.

**Skills Demonstrated:**
1. **Java Programming:** Proficiently using Java to implement various functionalities and algorithms.

2. **Object-Oriented Design:** Designing and structuring code using classes and objects to promote modularity.

3. **Generic Programming:** Implementing generic solutions that work with different data types.

4. **Method Implementation:** Creating methods to perform specific tasks and operations.

5. **Looping and Iteration:** Utilizing loops to iterate over data structures and perform repetitive tasks.

6. **Logical Thinking:** Developing logical strategies to solve problems and implement algorithms.

7. **Code Modularity:** Organizing code into smaller, reusable modules for better maintainability.

8. **Testing and Debugging:** Writing test cases to validate code functionality and identifying and fixing issues.

9. **Documentation:** Providing clear comments and documentation for code understanding and future reference.

10. **Technical Communication:** Effectively conveying ideas and solutions through code and documentation.

**2)Project Overview: proj2**
Create a utility for compressing and decompressing ASCII image files using the Run-Length Encoding (RLE) algorithm. This project demonstrates file I/O, the RLE compression technique, and unit testing.

**Skills Demonstrated:**

1. **File Handling:** Read and write data to/from files, highlighting data persistence skills.

2. **RLE Algorithm:** Implement RLE compression in the `compressLine` method.

3. **String Manipulation:** Convert between compressed and decompressed data formats.

4. **Looping:** Iterate through lines, characters, and compressed data.

5. **Array Usage:** Store lines, compressed data, and ASCII characters.

6. **Method Design:** Implement methods like `compressLine`, `compressAllLines`, and `decompressLine`.

7. **Unit Testing:** Validate the utility with JUnit test cases in `ProjectTests`.

8. **Code Structure:** Organize code into classes, methods, and tests for clarity.

9. **Technical Communication:** Use comments and method names for clear explanations.

This project illustrates compression concepts, file handling, and testing skills.

**3)Project Overview: project_sorting_starter**
This project focuses on creating a flexible sorting algorithm framework in Java. It includes classes for different sorting algorithms like Insertion Sort, Quick Sort, and Selection Sort. The project also introduces the concept of a specialized list interface named `SwapList`, optimized for in-place sorting while tracking comparisons and swaps.

**Skills Showcased:**
1) **Java Programming:** Proficiency in Java language, covering classes, interfaces, methods, and object-oriented concepts.

2) **Algorithm Implementation:** Demonstrates the ability to implement sorting algorithms like Insertion Sort, Quick Sort, and Selection Sort.

3) **Comparator Usage:** Utilizes Java's comparator for customized sorting orders in algorithms.

4) **Modularity:** The modular design allows easy integration of new sorting algorithms.

5) **Testing and Debugging:** Includes JUnit tests for algorithm validation and debugging practices.

6) **Optimization:** Employs efficient algorithms like Quick Sort with optimal time complexities.

7) **Problem Solving:** Solves sorting challenges while adhering to in-place constraints.

8) **Documentation:** Provides clear comments and documentation for code understanding.

Overall, the project showcases strong Java skills, algorithmic thinking, and software design for creating a versatile sorting algorithm framework.

**4)Project Overview: project_RecursiveList**
The Recursive List project focuses on implementing a dynamic linked list structure in Java, designed to handle various operations such as insertion, removal, and searching. The project introduces the concept of recursive data structures, enhancing the understanding of linked lists through practical implementation. The core component is the `RecursiveList` class, which provides functionalities for managing data elements and their relationships.

**Skills Showcased:**
1. **Java Programming Proficiency:** Demonstrates a strong grasp of Java programming concepts, including classes, methods, constructors, and data structures.

2. **Data Structure Implementation:** Illustrates the ability to create a complex data structure, such as a linked list, and manage its operations effectively.

3. **Recursive Design:** Showcases understanding and implementation of recursive design patterns to create dynamic data structures with self-referential properties.

4. **Exception Handling:** Utilizes Java's exception handling mechanisms to ensure robustness and prevent runtime errors during operations.

5. **Algorithmic Thinking:** Applies algorithmic thinking to design and implement essential operations like insertion, removal, and searching efficiently.

6. **Code Modularity:** Organizes code into methods and classes, demonstrating modular design practices for maintainability and readability.

7. **Debugging and Troubleshooting:** Utilizes debugging techniques to identify and resolve issues, ensuring the functionality of complex operations.

8. **Documentation Skills:** Employs clear comments and documentation to enhance code understanding and facilitate collaboration.

Overall, the Recursive List project showcases adept Java programming skills, proficiency in designing and implementing data structures, and a strong grasp of recursive concepts to build a functional linked list implementation.

**5)Project Overview: queues-student**
This project revolves around constructing a versatile unbounded queue in Java. The project encompasses the implementation of essential methods and functionalities for an unbounded queue data structure. It includes features like enqueueing, dequeuing, and peeking elements, along with providing a reversed version of the queue.

**Skills Demonstrated:**
1. **Java Proficiency:** Demonstrates a strong grasp of Java programming, utilizing classes, interfaces, and object-oriented principles.

2. **Data Structure Design:** Successfully designs and implements an unbounded queue, encompassing essential methods.

3. **Method Implementation:** Implements key operations such as enqueue, dequeue, and peek, ensuring accurate functionality.

4. **Error Handling:** Implements appropriate exception handling, ensuring proper behavior even in exceptional cases.

5. **Algorithmic Efficiency:** Ensures optimal time complexity for enqueue, dequeue, and peek operations.

6. **Method Testing:** Develops comprehensive JUnit tests to validate the correctness of implemented methods.

7. **Problem-Solving:** Adopts efficient strategies to reverse the queue while adhering to time complexity constraints.

8. **Documentation:** Provides clear and concise comments, enabling easy understanding of the implemented code.
   
In essence, the project aptly showcases proficiency in Java programming, data structure implementation, algorithmic thinking, and a focus on delivering functional and efficient code for an unbounded queue.

**6)Project Overview bst-student**
This project focuses on implementing a Binary Search Tree (BST) data structure in Java. The project includes the creation of classes to construct and manage the BST, along with implementing essential methods such as insertion, removal, searching, and traversal. The project also provides functionalities to calculate the size, height, and count of elements within specified ranges in the tree.

**Skills Demonstrated:**
- **Java Programming:** Proficient use of Java, including classes, interfaces, methods, and object-oriented concepts.
- **Data Structure Implementation:** Successfully designs and implements a Binary Search Tree with various methods for tree manipulation.
- **Recursion:** Utilizes recursive techniques to perform tree traversal and various operations within the tree structure.
- **Method Implementation:** Implements key BST operations such as insertion, removal, searching, and traversal methods.
- **Error Handling:** Implements proper exception handling and null checks to ensure robust code behavior.
- **Algorithmic Thinking:** Applies algorithms for searching, inserting, and removing elements in a BST.
- **Testing and Debugging:** Demonstrates thorough testing of implemented methods using various scenarios.
- **Documentation:** Provides clear comments and documentation, enhancing code readability and comprehension.
- **Graph Visualization:** Implements a method to generate a DOT format representation of the BST for visualization.

In summary, the project showcases adeptness in Java programming, data structure implementation, recursion, and algorithmic reasoning while constructing and managing a Binary Search Tree with essential functionalities.

**7)Project Overview: bst-avl-student**
This project involves the creation of an AVL Tree implementation in Java. The AVL Tree is a self-balancing binary search tree, ensuring that the height difference between its left and right subtrees (balance factor) does not exceed a certain threshold. The project includes classes to construct and manage the AVL Tree, along with methods for insertion, height calculation, balancing, and rotation.

**Skills Demonstrated:**
- **Java Programming:** Proficiency in Java programming, including classes, interfaces, methods, and object-oriented concepts.
- **Data Structure Implementation:** Successful creation and management of an AVL Tree, a self-balancing binary search tree.
- **Self-Balancing Algorithms:** Implements AVL Tree self-balancing algorithms to maintain balanced tree structure during insertion.
- **Recursion:** Utilizes recursive techniques for height calculation, balancing factor computation, and rebalancing.
- **Method Implementation:** Implements methods for inserting nodes, calculating height, computing balance factors, and performing rotations.
- **Algorithmic Thinking:** Applies AVL Tree balancing strategies (rotations) based on balance factors to achieve optimal performance.
- **Documentation:** Provides clear comments and documentation to enhance code readability and understanding.

In summary, the project showcases strong Java programming skills and data structure implementation knowledge by constructing and maintaining an AVL Tree with automatic balancing to optimize search and insertion performance.

**8)Project Overview: proj8-patient**

This project involves building a heap-based priority queue in Java. The priority queue efficiently manages elements with associated priorities using a binary heap. This allows for quick insertion, removal, and retrieval based on priority.

**Skills Demonstrated:**

1. **Data Structures and Algorithms:** Implemented heap operations like "bubble up" and "bubble down" to maintain the heap structure efficiently.

2. **Generic Programming:** Developed a flexible solution that works with various data types using Java generics.

3. **Object-Oriented Programming (OOP):** Designed classes for encapsulating data and behavior, promoting code modularity.

4. **Exception Handling:** Created a custom exception class to handle empty queue scenarios during dequeue.

5. **Comparator and Comparable:** Utilized interfaces for custom comparison rules, showing understanding of sorting concepts.

6. **Memory Management:** Managed array resizing to accommodate elements and prevent memory issues.

7. **Problem Solving and Logic:** Implemented logic to balance the heap after operations like insertion and removal.

8. **Software Engineering Practices:** Organized code into classes and methods, enhancing readability and maintenance.

9. **Code Reusability:** Defined an abstract interface for future implementations, focusing on clear external usage.

10. **Testing and Debugging:** Created test cases, ensuring accurate method functionality and error handling.

11. **Version Control:** Managed project versions using Git, supporting collaboration and code tracking.

12. **Complexity Analysis:** Evaluated time complexity for key operations, aiding in understanding efficiency.

By completing this project, the programmer showcases proficiency in programming concepts, data structures, algorithms, and software design principles.

**9)Project Overview: proj9-login**

This project involves creating a hash table data structure in Java that supports generic key-value pairs. The hash table utilizes an array backend and employs open addressing to handle collisions. Two collision handling strategies are provided: linear probing and quadratic probing.

**Skills Demonstrated:**

1. **Data Structures:** Developed a hash table to efficiently store key-value pairs using arrays and collision handling mechanisms.

2. **Generic Programming:** Implemented a flexible solution that works with various key and value data types using Java generics.

3. **Object-Oriented Programming (OOP):** Designed classes for encapsulating data and behavior, promoting code modularity and reusability.

4. **Interface Implementation:** Implemented the `HashTable` interface, showcasing the ability to define and adhere to interfaces in Java.

5. **Algorithmic Problem Solving:** Implemented collision handling methods like linear probing and quadratic probing to efficiently resolve hash collisions.

6. **Exception Handling:** Created custom exception classes (`ElementNotFoundException`) to handle exceptional situations.

7. **Iterator Design:** Designed and implemented an iterator (`KeyIterator`) to iterate over the keys in the hash table.

8. **Software Engineering Practices:** Structured the code into cohesive classes and methods, enhancing code readability and maintainability.

9. **Code Testing and Debugging:** Utilized test cases to validate the functionality of the hash table, collision handlers, and iterators.

10. **Code Documentation:** Added comments to explain the purpose and functionality of methods, promoting code understanding.

12. **Mathematical and Logical Thinking:** Applied mathematical formulas for hash calculations and collision resolution strategies.

13. **Efficiency and Optimization:** Addressed the resizing of the hash table to manage load factor and ensure efficient operations.

Through this project,proficiency in data structures, algorithms, object-oriented programming, and software design principles required for developing robust and efficient data storage solutions is demonstrated.

**10)Project Overview: proj10_starter**
This project involves creating and solving mazes using various search algorithms in Java.

Skills Demonstrated:

1. **Algorithm Implementation:** Implementing search algorithms like depth-first search (DFS) and breadth-first search (BFS) for maze-solving.
2. **Data Structures:** Utilizing queues and stacks for BFS and DFS implementations, respectively.
3. **Object-Oriented Design:** Designing classes to represent mazes, cells, and search algorithms, enhancing code organization.
4. **Problem Solving:** Developing strategies to navigate through mazes efficiently, finding paths from start to goal.
5. **Code Testing:** Creating and executing test cases to validate algorithm correctness and solution validity.
6. **Software Modularity:** Organizing code into separate classes and methods, promoting code reusability and maintainability.
7. **Java Generics:** Applying generics to handle different types of maze elements and search states.
8. **Exception Handling:** Implementing error handling for scenarios like invalid paths and unreachable goals.
9. **Version Control:** Using version control tools like Git for tracking changes and collaborating effectively.
10. **Documentation:** Providing clear comments and documentation for code understanding and future reference.

Through this project, the ability to implement algorithms, work with data structures, design classes, and solve complex problems while adhering to best coding practices is demonstred.

